fn sqrt(x: float) -> float {
    var z: float = 1.0;
    for var i = 1; i <= 10; i += 1 {
        z -= (z*z - x) / (2.0 *z); // MAGIC LINE!!
    }
    return z;
}

fn compare_float(f1: float, f2: float) -> int {
const precision: float = 0.00000000000000000001;
    if ((f1 - precision) < f2) {
        return -1;
    }
    else if ((f1 + precision) > f2) {
        return 1;
    }
    else {
        return 0;
    }
}

const PI = 3.14159265358979;
fn cos(x: float) -> float {
    if x < 0.0 {
        x = -x;
    }
    
    if 0 <= compare_float(x,PI) {
        x -= PI;
        while(0 <= compare_float(x,PI)) {
            x -= PI;
        }
    }
    
    if ((0 <= compare_float(x, PI)) and (-1 == compare_float(x, PI))) {
        x -= PI;
        return ((-1.0)*(1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))))));
    } 

    return 1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))));
}

fn sin(x: float) -> float {
    return cos(x - PI);
}

fn pow(x: float, y: int) -> float {
    var result = 1.0;
    for var i = 0; i < y; i += 1 {
        result *= x;
    }

    return result;
}


struct Vec3 {
    vec: float[];

    fn dot(v2: Vec3) -> float {
        return self.vec[0] * v2.vec[0] + self.vec[1] * v2.vec[1] + self.vec[2] * v2.vec[2];
    }

    fn cross(v2: Vec3) -> Vec3 {
        return Vec3 {vec = [
            self.vec[1] * v2.vec[2] - self.vec[2] * v2.vec[1],
            -(self.vec[0] * v2.vec[2] - self.vec[2] * v2.vec[0]),
            self.vec[0] * v2.vec[1] - self.vec[1] * v2.vec[0]
        ]};
    }

    fn normalize() -> Vec3 {
        var squared_sum: float = 0.0;
        for var i = 0; i < 3; i += 1 {
            squared_sum += pow(self.vec[i], 2);
        }

        var magnitude: float = sqrt(squared_sum);

        const new_vec: float[] = [];
        for var i = 0; i < 3; i += 1 {
            push(new_vec, self.vec[i] / magnitude);
        }

        return Vec3 {
            vec = new_vec
        };
    }

    fn minus(v2: Vec3) -> Vec3 {
        return Vec3 {
            vec = [self.vec[0] - v2.vec[0], self.vec[1] - v2.vec[1], self.vec[2] - v2.vec[2]]
        };
    }

    fn show_v3() -> void {
        for var i = 0; i < 3; i += 1 {
            print self.vec[i];
        }
    }
};

struct Vec4 {
    vec: float[];

    fn show_v4() -> void {
        for var i = 0; i < 4; i += 1 {
            print self.vec[i];
        }
    }
};

fn v4_from_v3(v: Vec3, w: float) -> Vec4 {
    return Vec4 {
        vec = [v.vec[0], v.vec[1], v.vec[2], w]
    };
}

struct Mat3 {
    matrix: float[][];

    fn adjugate() -> Mat3 {
        const adj: float[][] = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        adj[0][0] = (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]);
        adj[0][1] = -(self.matrix[0][1] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][1]);
        adj[0][2] = (self.matrix[0][1] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][1]);
        adj[1][0] = -(self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]);
        adj[1][1] = (self.matrix[0][0] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][0]);
        adj[1][2] = -(self.matrix[0][0] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][0]);
        adj[2][0] = (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
        adj[2][1] = -(self.matrix[0][0] * self.matrix[2][1] - self.matrix[0][1] * self.matrix[2][0]);
        adj[2][2] = (self.matrix[0][0] * self.matrix[1][1] - self.matrix[0][1] * self.matrix[1][0]);

        return Mat3 {
            matrix = adj
        };
    }

    fn determinant() -> float {
        return self.matrix[0][0] * (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]) -
            self.matrix[0][1] * (self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]) +
            self.matrix[0][2] * (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
    }

    fn invert() -> Mat3 {
        const det: float = self.determinant();
        if det == 0.0 {
            return Mat3 {
                matrix = [
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0]
                ]
            };
        }

        const adj: Mat3 = self.adjugate();
        const inverse = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                inverse[i][j] = adj.matrix[i][j] / det;
            }
        }

        return Mat3 {
            matrix = inverse
        };
    }

    fn mul_vec3(v: Vec3) -> Vec3 {
        const result = [0.0, 0.0, 0.0];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec3 {
            vec = result
        };
    }

    fn mul3(m: Mat3) -> Mat3 {
        const result = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                for var k = 0; k < 3; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat3 {
            matrix = result
        };
    }

    fn show_m3() -> void {
        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};



struct Mat4 {
    matrix: float[][];

    fn mul_vec4(v: Vec4) -> Vec4 {
        const result = [0.0, 0.0, 0.0, 0.0];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec4 {
            vec = result
        };
    }

    fn mul4(m: Mat4) -> Mat4 {
        const result = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                for var k = 0; k < 4; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat4 {
            matrix = result
        }; 
    }

    fn translate(v: Vec3) -> Mat4 {
        const transMat = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, v.vec[0]],
                [0.0, 1.0, 0.0, v.vec[1]],
                [0.0, 0.0, 1.0, v.vec[2]],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        return self.mul4(transMat.T());
    }

    fn rotate(angle: float, vaxis: Vec3) -> Mat4 {
        const angleRad: float = (angle * PI) / 180.0;
        const result = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        const cos = cos(angleRad);
        const sin = sin(angleRad);

        if (vaxis.vec[0] > 0.0 or vaxis.vec[0] < 0.0) {
            result.matrix[1][1] = cos;
            result.matrix[1][2] = -sin;
            result.matrix[2][1] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[1] > 0.0 or vaxis.vec[1] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][2] = -sin;
            result.matrix[2][0] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[2] > 0.0 or vaxis.vec[2] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][1] = -sin;
            result.matrix[1][0] = sin;
            result.matrix[1][1] = cos;
        }

        return result.mul4(self);
    }

    fn T() -> Mat4 {
        const new: float[][] = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                new[i][j] = self.matrix[j][i];
            }
        }

        return Mat4 {
            matrix = new
        };
    }

    fn show_m4() {
        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};

struct Cube {
    vertices: Vec3[];
    indices: int[];
    colors: Vec3[];
};

fn create_cube() -> Cube {
    const vertices: Vec3[] = [
        Vec3 {vec = [ 1.0, -1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, -1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, -1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, -1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, 1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, 1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, 1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, 1.0, -1.0 ]}
    ];

    const indices: int[] = [1, 3, 0, 7, 5, 4, 4, 1, 0, 5, 2, 1, 2, 7, 3, 0, 7, 4, 1, 2, 3, 7, 6, 5, 4, 5, 1, 5, 6, 2, 2, 6, 7, 0, 3, 7];

    const colors = [
        Vec3 {vec = [0.0, 0.0, 1.0]},
        Vec3 {vec = [0.0, 1.0, 0.0]},
        Vec3 {vec = [0.0, 1.0, 1.0]},
        Vec3 {vec = [1.0, 1.0, 1.0]},
        Vec3 {vec = [1.0, 0.0, 1.0]},
        Vec3 {vec = [1.0, 1.0, 0.0]}
    ];

    return Cube {
        vertices = vertices,
        indices = indices,
        colors = colors
    };
}

const sWidth = 400;
const sHeight = 300;

fn to_raster(v: Vec4) -> Vec4 {
    return Vec4 {
        vec = [
            (sWidth as float) * (v.vec[0] + v.vec[3]) / 2.0,
            (sHeight as float) * (v.vec[3] - v.vec[1]) / 2.0,
            v.vec[2],
            v.vec[3]
        ]
    };
}

fn raster() -> float[] {
    const eye: Mat4 = Mat4 {
        matrix = [
            [1.0, 0.0, 0.0, 0.0],
            [1.0, 0.0, 0.0, 0.0],
            [1.0, 0.0, 0.0, 0.0],
            [1.0, 0.0, 0.0, 0.0]
        ]
    };

    var objs: Mat4[] = [];
    eye.translate(Vec3{vec = [0.0, 0.0, 0.2]});
    push(objs, eye.rotate(45.0, Vec3{vec = [0.0, 1.0, 0.0]}));

    const frameBuffer: float[] = [];
    for var i = 0; i < sHeight * sWidth; i += 1 {
        push(frameBuffer, 0.0);
    }

    const cube: Cube = create_cube();
    // for var i = 0; i < 1; i += 1 {
    //     for var j = 0; j < length(cube.indices) / 3; j += 1 {
    //         const v0 = cube.vertices[cube.indices[i * 3]];
    //         const v1 = cube.vertices[cube.indices[i * 3 + 1]];
    //         const v2 = cube.vertices[cube.indices[i * 3 + 2]];

    //         const color = cube.colors[cube.indices[i * 3] % 6];
    //     }
    // }

    return frameBuffer;
}
