fn sqrt(x: float) -> float {
    var z: float = 1.0;
    for var i = 1; i <= 10; i += 1 {
        z -= (z*z - x) / (2.0 *z); // MAGIC LINE!!
    }
    return z;
}

fn compare_float(f1: float, f2: float) -> int {
const precision: float = 0.00000000000000000001;
    if ((f1 - precision) < f2) {
        return -1;
    }
    else if ((f1 + precision) > f2) {
        return 1;
    }
    else {
        return 0;
    }
}

const PI = 3.14159265358979;
fn cos(x: float) -> float {
    if x < 0.0 {
        x = -x;
    }
    
    if 0 <= compare_float(x,PI) {
        x -= PI;
        while(0 <= compare_float(x,PI)) {
            x -= PI;
        }
    }
    
    if ((0 <= compare_float(x, PI)) and (-1 == compare_float(x, PI))) {
        x -= PI;
        return ((-1.0)*(1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))))));
    } 

    return 1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))));
}

fn sin(x: float) -> float {
    return cos(x - PI);
}

fn pow(x: float, y: int) -> float {
    var result = 1.0;
    for var i = 0; i < y; i += 1 {
        result *= x;
    }

    return result;
}

fn tan(x: float) -> float {
    return x + pow(x, 3)/3.0 + (2.0*pow(x, 5))/15.0;
}

struct Vec3 {
    vec: float[];

    fn dot(v2: Vec3) -> float {
        return self.vec[0] * v2.vec[0] + self.vec[1] * v2.vec[1] + self.vec[2] * v2.vec[2];
    }

    fn cross(v2: Vec3) -> Vec3 {
        return Vec3 {vec = [
            self.vec[1] * v2.vec[2] - self.vec[2] * v2.vec[1],
            -(self.vec[0] * v2.vec[2] - self.vec[2] * v2.vec[0]),
            self.vec[0] * v2.vec[1] - self.vec[1] * v2.vec[0]
        ]};
    }

    fn normalize() -> Vec3 {
        var squared_sum: float = 0.0;
        for var i = 0; i < 3; i += 1 {
            squared_sum += pow(self.vec[i], 2);
        }

        var magnitude: float = sqrt(squared_sum);

        const new_vec: float[] = [];
        for var i = 0; i < 3; i += 1 {
            push(new_vec, self.vec[i] / magnitude);
        }

        const result = Vec3 {
            vec = new_vec
        };

        return result;
    }

    fn minus(v2: Vec3) -> Vec3 {
        return Vec3 {
            vec = [self.vec[0] - v2.vec[0], self.vec[1] - v2.vec[1], self.vec[2] - v2.vec[2]]
        };
    }

    fn show_v3() -> void {
        for var i = 0; i < 3; i += 1 {
            print self.vec[i];
        }
    }
};

struct Vec4 {
    vec: float[];

    fn show_v4() -> void {
        for var i = 0; i < 4; i += 1 {
            print self.vec[i];
        }
    }
};

fn v4_from_v3(v: Vec3, w: float) -> Vec4 {
    return Vec4 {
        vec = [v.vec[0], v.vec[1], v.vec[2], w]
    };
}

struct Mat3 {
    matrix: float[][];

    fn adjugate() -> Mat3 {
        const adj: float[][] = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        adj[0][0] = (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]);
        adj[0][1] = -(self.matrix[0][1] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][1]);
        adj[0][2] = (self.matrix[0][1] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][1]);
        adj[1][0] = -(self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]);
        adj[1][1] = (self.matrix[0][0] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][0]);
        adj[1][2] = -(self.matrix[0][0] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][0]);
        adj[2][0] = (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
        adj[2][1] = -(self.matrix[0][0] * self.matrix[2][1] - self.matrix[0][1] * self.matrix[2][0]);
        adj[2][2] = (self.matrix[0][0] * self.matrix[1][1] - self.matrix[0][1] * self.matrix[1][0]);

        return Mat3 {
            matrix = adj
        };
    }

    fn determinant() -> float {
        return self.matrix[0][0] * (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]) -
            self.matrix[0][1] * (self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]) +
            self.matrix[0][2] * (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
    }

    fn invert() -> Mat3 {
        const det: float = self.determinant();
        if det == 0.0 {
            return Mat3 {
                matrix = [
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0]
                ]
            };
        }

        const adj: Mat3 = self.adjugate();
        const inverse = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                inverse[i][j] = adj.matrix[i][j] / det;
            }
        }

        return Mat3 {
            matrix = inverse
        };
    }

    fn mul_vec3(v: Vec3) -> Vec3 {
        const result = [0.0, 0.0, 0.0];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec3 {
            vec = result
        };
    }

    fn mul3(m: Mat3) -> Mat3 {
        const result = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                for var k = 0; k < 3; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat3 {
            matrix = result
        };
    }

    fn show_m3() -> void {
        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};



struct Mat4 {
    matrix: float[][];

    fn mul_vec4(v: Vec4) -> Vec4 {
        const result = [0.0, 0.0, 0.0, 0.0];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec4 {
            vec = result
        };
    }

    fn mul4(m: Mat4) -> Mat4 {
        const result = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                for var k = 0; k < 4; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat4 {
            matrix = result
        }; 
    }

    fn translate(v: Vec3) -> Mat4 {
        const transMat = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, v.vec[0]],
                [0.0, 1.0, 0.0, v.vec[1]],
                [0.0, 0.0, 1.0, v.vec[2]],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        return self.mul4(transMat.T());
    }

    fn rotate(angle: float, vaxis: Vec3) -> Mat4 {
        const angleRad: float = (angle * PI) / 180.0;
        const result = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        const cos = cos(angleRad);
        const sin = sin(angleRad);

        if (vaxis.vec[0] > 0.0 or vaxis.vec[0] < 0.0) {
            result.matrix[1][1] = cos;
            result.matrix[1][2] = -sin;
            result.matrix[2][1] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[1] > 0.0 or vaxis.vec[1] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][2] = -sin;
            result.matrix[2][0] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[2] > 0.0 or vaxis.vec[2] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][1] = -sin;
            result.matrix[1][0] = sin;
            result.matrix[1][1] = cos;
        }

        return result.mul4(self);
    }

    fn T() -> Mat4 {
        const new: float[][] = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                new[i][j] = self.matrix[j][i];
            }
        }

        return Mat4 {
            matrix = new
        };
    }

    fn show_m4() {
        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};

fn look_at(eye: Vec3, center: Vec3, up: Vec3) -> Mat4{
    const result = [
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0]
    ];

    const f = (center.minus(eye)).normalize();
    var u = up.normalize();
    const s = f.cross(u).normalize();
    u = s.cross(f);

    result[0][0] = s.vec[0];
    result[1][0] = s.vec[1];
    result[2][0] = s.vec[2];
    result[0][1] = u.vec[0];
    result[1][1] = u.vec[1];
    result[2][1] = u.vec[2];
    result[0][2] = -f.vec[0];
    result[1][2] = -f.vec[1];
    result[2][2] = -f.vec[2];
    result[3][0] = -s.dot(eye);
    result[3][1] = -u.dot(eye);
    result[3][2] = f.dot(eye);

    return Mat4 {
        matrix = result
    };
}

fn perspective(fovy: float, aspect: float, near: float, far: float) -> Mat4 {
    const result = [
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0]
    ];

    const angle_rad = (fovy * PI) / 180.0;
    const tan_half_fovy = tan(angle_rad / 2.0);

    result[0][0] = 1.0 / (aspect * tan_half_fovy);
    result[1][1] = 1.0 / tan_half_fovy;
    result[2][2] = -(far + near) / (far - near);
    result[2][3] = -1.0;
    result[3][2] = -(2.0 * far * near) / (far - near);

    return Mat4 {
        matrix = result
    };
}

struct Cube {
    vertices: Vec3[];
    indices: int[];
    colors: int[];
};

fn create_cube() -> Cube {
    const vertices: Vec3[] = [
        Vec3 {vec = [ 1.0, -1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, -1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, -1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, -1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, 1.0, -1.0 ]},
        Vec3 {vec = [ 1.0, 1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, 1.0, 1.0 ]},
        Vec3 {vec = [ -1.0, 1.0, -1.0 ]}
    ];

    const indices: int[] = [1, 3, 0, 7, 5, 4, 4, 1, 0, 5, 2, 1, 2, 7, 3, 0, 7, 4, 1, 2, 3, 7, 6, 5, 4, 5, 1, 5, 6, 2, 2, 6, 7, 0, 3, 7];

    const colors = [
        -65536,
        -16711936,
        -256,
        -1,
        -65281,
        -16711681
    ];

    return Cube {
        vertices = vertices,
        indices = indices,
        colors = colors
    };
}

const sWidth = 200;
const sHeight = 150;

fn to_raster(v: Vec4) -> Vec4 {
    return Vec4 {
        vec = [
            (sWidth as float) * (v.vec[0] + v.vec[3]) / 2.0,
            (sHeight as float) * (v.vec[3] - v.vec[1]) / 2.0,
            v.vec[2],
            v.vec[3]
        ]
    };
}

const view = look_at(Vec3{ vec = [0.0, 3.75, 6.5] }, Vec3{ vec = [0.0, 0.0, 0.0] }, Vec3{ vec = [0.0, 1.0, 0.0] });
const proj = perspective(60.0, ( sWidth as float ) / ( sHeight as float ), 0.1, 100.0);

const eye: Mat4 = Mat4 {
    matrix = [
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0]
    ]
};

eye.translate(Vec3{vec = [0.0, 0.0, 0.2]});
var obj: Mat4 = eye.rotate(45.0, Vec3{vec = [0.0, 1.0, 0.0]});
const frame_buffer: int[] = [];
for var i = 0; i < sHeight * sWidth; i += 1 {
    push(frame_buffer, 0);
}

fn raster() -> int[] {
    for var i = 0; i < sHeight * sWidth; i += 1 {
        frame_buffer[i] = 0;
    }

    const cube: Cube = create_cube();
    for var j = 0; j < length(cube.indices) / 3; j += 1 {
        const v0 = cube.vertices[cube.indices[j * 3]];
        const v1 = cube.vertices[cube.indices[j * 3 + 1]];
        const v2 = cube.vertices[cube.indices[j * 3 + 2]];

        const color = cube.colors[cube.indices[j * 3] % 6];

        const v0clip = proj.mul_vec4(view.mul_vec4(obj.mul_vec4(v4_from_v3(v0, 1.0))));
        const v1clip = proj.mul_vec4(view.mul_vec4(obj.mul_vec4(v4_from_v3(v1, 1.0))));
        const v2clip = proj.mul_vec4(view.mul_vec4(obj.mul_vec4(v4_from_v3(v2, 1.0))));

        const v0Homo = to_raster(v0clip);
        const v1Homo = to_raster(v1clip);
        const v2Homo = to_raster(v2clip);
                
        const m = Mat3 {
            matrix = [
                [v0Homo.vec[0], v1Homo.vec[0], v2Homo.vec[0]],
                [v0Homo.vec[1], v1Homo.vec[1], v2Homo.vec[1]],
                [v0Homo.vec[3], v1Homo.vec[3], v2Homo.vec[3]]
            ]
        };

        const det = m.determinant();
        if (det >= 0.0) {
            continue;
        }

        const inv = m.invert();
        const e0 = inv.mul_vec3(Vec3 {vec = [1.0, 0.0, 0.0]});
        const e1 = inv.mul_vec3(Vec3 {vec = [0.0, 1.0, 0.0]});
        const e2 = inv.mul_vec3(Vec3 {vec = [0.0, 0.0, 1.0]});

        const c = inv.mul_vec3(Vec3 {vec = [1.0, 1.0, 1.0]});

        for var k = 0; k < sHeight; k += 1 {
            for var l = 0; l < sWidth; l += 1 {
                const sample = Vec3 {vec = [l as float + 0.5, k as float + 0.5, 1.0]};

                const alpha = e0.dot(sample);
                const beta = e1.dot(sample);
                const gamma = e2.dot(sample);

                if (alpha >= 0.0) and (beta >= 0.0) and (gamma >= 0.0) {
                    frame_buffer[l + k * sWidth] = color;
                }
            }
        }
    }
    
    return frame_buffer;
}

