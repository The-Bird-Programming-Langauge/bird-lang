fn sqrt(x: float) -> float {
    var z: float = 1.0;
    for var i = 1; i <= 10; i += 1 {
        z -= (z*z - x) / (2.0 *z); // MAGIC LINE!!
    }
    return z;
}

fn compare_float(f1: float, f2: float) -> int {
const precision: float = 0.00000000000000000001;
    if ((f1 - precision) < f2) {
        return -1;
    }
    else if ((f1 + precision) > f2) {
        return 1;
    }
    else {
        return 0;
    }
}

const PI = 3.14159265358979;
fn cos(x: float) -> float {
    if x < 0.0 {
        x = -x;
    }
    
    if 0 <= compare_float(x,PI) {
        x -= PI;
        while(0 <= compare_float(x,PI)) {
            x -= PI;
        }
    }
    
    if ((0 <= compare_float(x, PI)) and (-1 == compare_float(x, PI))) {
        x -= PI;
        return ((-1.0)*(1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))))));
    } 

    return 1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))));
}

fn sin(x: float) -> float {
    return cos(x - PI);
}

fn pow(x: float, y: int) -> float {
    var result = 1.0;
    for var i = 0; i < y; i += 1 {
        result *= x;
    }

    return result;
}


struct Vec3 {
    vec: float[];

    fn dot(v2: Vec3) -> float {
        return self.vec[0] * v2.vec[0] + self.vec[1] * v2.vec[1] + self.vec[2] * v2.vec[2];
    }

    fn cross(v2: Vec3) -> Vec3 {
        return Vec3 {vec = [
            self.vec[1] * v2.vec[2] - self.vec[2] * v2.vec[1],
            -(self.vec[0] * v2.vec[2] - self.vec[2] * v2.vec[0]),
            self.vec[0] * v2.vec[1] - self.vec[1] * v2.vec[0]
        ]};
    }

    fn normalize() -> Vec3 {
        var squared_sum: float = 0.0;
        for var i = 0; i < 3; i += 1 {
            squared_sum += pow(self.vec[i], 2);
        }

        var magnitude: float = sqrt(squared_sum);

        const new_vec: float[] = [];
        for var i = 0; i < 3; i += 1 {
            push(new_vec, self.vec[i] / magnitude);
        }

        return Vec3 {
            vec = new_vec
        };
    }

    fn minus(v2: Vec3) -> Vec3 {
        return Vec3 {
            vec = [self.vec[0] - v2.vec[0], self.vec[1] - v2.vec[1], self.vec[2] - v2.vec[2]]
        };
    }

    fn show_v3() -> void {
        for var i = 0; i < 3; i += 1 {
            print self.vec[i];
        }
    }
};

struct Vec4 {
    vec: float[];

    fn show_v4() -> void {
        for var i = 0; i < 4; i += 1 {
            print self.vec[i];
        }
    }
};

fn v4_from_v3(v: Vec3, w: float) -> Vec4 {
    return Vec4 {
        vec = [v.vec[0], v.vec[1], v.vec[2], w]
    };
}

print sqrt(4.5);
print cos(-3.0 * PI / 4.0);


const v1 = Vec3 {vec = [1.0, 2.0, 3.0]};
const v2 = Vec3 {vec = [3.0, 2.0, 1.0]};

v1.show_v3();
v2.show_v3();

const v4 = v4_from_v3(v1, 1.0);
v4.show_v4();






