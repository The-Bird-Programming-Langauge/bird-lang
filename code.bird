fn sqrt(x: float) -> float {
    var z: float = 1.0;
    for var i = 1; i <= 10; i += 1 {
        z -= (z*z - x) / (2.0 *z); // MAGIC LINE!!
    }
    return z;
}

fn compare_float(f1: float, f2: float) -> int {
const precision: float = 0.00000000000000000001;
    if ((f1 - precision) < f2) {
        return -1;
    }
    else if ((f1 + precision) > f2) {
        return 1;
    }
    else {
        return 0;
    }
}

const PI = 3.14159265358979;
fn cos(x: float) -> float {
    if x < 0.0 {
        x = -x;
    }
    
    if 0 <= compare_float(x,PI) {
        x -= PI;
        while(0 <= compare_float(x,PI)) {
            x -= PI;
        }
    }
    
    if ((0 <= compare_float(x, PI)) and (-1 == compare_float(x, PI))) {
        x -= PI;
        return ((-1.0)*(1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))))));
    } 

    return 1.0 - (x*x/2.0)*( 1.0 - (x*x/12.0) * ( 1.0 - (x*x/30.0) * (1.0 - (x*x/56.0 )*(1.0 - (x*x/90.0)*(1.0 - (x*x/132.0)*(1.0 - (x*x/182.0)))))));
}

fn sin(x: float) -> float {
    return cos(x - PI);
}

fn pow(x: float, y: int) -> float {
    var result = 1.0;
    for var i = 0; i < y; i += 1 {
        result *= x;
    }

    return result;
}


struct Vec3 {
    vec: float[];

    fn dot(v2: Vec3) -> float {
        return self.vec[0] * v2.vec[0] + self.vec[1] * v2.vec[1] + self.vec[2] * v2.vec[2];
    }

    fn cross(v2: Vec3) -> Vec3 {
        return Vec3 {vec = [
            self.vec[1] * v2.vec[2] - self.vec[2] * v2.vec[1],
            -(self.vec[0] * v2.vec[2] - self.vec[2] * v2.vec[0]),
            self.vec[0] * v2.vec[1] - self.vec[1] * v2.vec[0]
        ]};
    }

    fn normalize() -> Vec3 {
        var squared_sum: float = 0.0;
        for var i = 0; i < 3; i += 1 {
            squared_sum += pow(self.vec[i], 2);
        }

        var magnitude: float = sqrt(squared_sum);

        const new_vec: float[] = [];
        for var i = 0; i < 3; i += 1 {
            push(new_vec, self.vec[i] / magnitude);
        }

        return Vec3 {
            vec = new_vec
        };
    }

    fn minus(v2: Vec3) -> Vec3 {
        return Vec3 {
            vec = [self.vec[0] - v2.vec[0], self.vec[1] - v2.vec[1], self.vec[2] - v2.vec[2]]
        };
    }

    fn show_v3() -> void {
        for var i = 0; i < 3; i += 1 {
            print self.vec[i];
        }
    }
};

struct Vec4 {
    vec: float[];

    fn show_v4() -> void {
        for var i = 0; i < 4; i += 1 {
            print self.vec[i];
        }
    }
};

fn v4_from_v3(v: Vec3, w: float) -> Vec4 {
    return Vec4 {
        vec = [v.vec[0], v.vec[1], v.vec[2], w]
    };
}

struct Mat3 {
    matrix: float[][];

    fn adjugate() -> Mat3 {
        const adj: float[][] = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        adj[0][0] = (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]);
        adj[0][1] = -(self.matrix[0][1] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][1]);
        adj[0][2] = (self.matrix[0][1] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][1]);
        adj[1][0] = -(self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]);
        adj[1][1] = (self.matrix[0][0] * self.matrix[2][2] - self.matrix[0][2] * self.matrix[2][0]);
        adj[1][2] = -(self.matrix[0][0] * self.matrix[1][2] - self.matrix[0][2] * self.matrix[1][0]);
        adj[2][0] = (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
        adj[2][1] = -(self.matrix[0][0] * self.matrix[2][1] - self.matrix[0][1] * self.matrix[2][0]);
        adj[2][2] = (self.matrix[0][0] * self.matrix[1][1] - self.matrix[0][1] * self.matrix[1][0]);

        return Mat3 {
            matrix = adj
        };
    }

    fn determinant() -> float {
        return self.matrix[0][0] * (self.matrix[1][1] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][1]) -
            self.matrix[0][1] * (self.matrix[1][0] * self.matrix[2][2] - self.matrix[1][2] * self.matrix[2][0]) +
            self.matrix[0][2] * (self.matrix[1][0] * self.matrix[2][1] - self.matrix[1][1] * self.matrix[2][0]);
    }

    fn invert() -> Mat3 {
        const det: float = self.determinant();
        if det == 0.0 {
            return Mat3 {
                matrix = [
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0]
                ]
            };
        }

        const adj: Mat3 = self.adjugate();
        const inverse = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                inverse[i][j] = adj.matrix[i][j] / det;
            }
        }

        return Mat3 {
            matrix = inverse
        };
    }

    fn mul_vec3(v: Vec3) -> Vec3 {
        const result = [0.0, 0.0, 0.0];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec3 {
            vec = result
        };
    }

    fn mul3(m: Mat3) -> Mat3 {
        const result = [
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                for var k = 0; k < 3; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat3 {
            matrix = result
        };
    }

    fn show_m3() -> void {
        for var i = 0; i < 3; i += 1 {
            for var j = 0; j < 3; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};



struct Mat4 {
    matrix: float[][];

    fn mul_vec4(v: Vec4) -> Vec4 {
        const result = [0.0, 0.0, 0.0, 0.0];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                result[i] += self.matrix[j][i] * v.vec[j];
            }
        }

        return Vec4 {
            vec = result
        };
    }

    fn mul4(m: Mat4) -> Mat4 {
        const result = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                for var k = 0; k < 4; k += 1 {
                    result[i][j] += self.matrix[i][k] * m.matrix[k][j];
                }
            }
        }

        return Mat4 {
            matrix = result
        }; 
    }

    fn translate(v: Vec3) -> Mat4 {
        const transMat = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, v.vec[0]],
                [0.0, 1.0, 0.0, v.vec[1]],
                [0.0, 0.0, 1.0, v.vec[2]],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        return self.mul4(transMat.T());
    }

    fn rotate(angle: float, vaxis: Vec3) -> Mat4 {
        const angleRad: float = (angle * PI) / 180.0;
        const result = Mat4 {
            matrix = [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ]
        };

        const cos = cos(angleRad);
        const sin = sin(angleRad);

        if (vaxis.vec[0] > 0.0 or vaxis.vec[0] < 0.0) {
            result.matrix[1][1] = cos;
            result.matrix[1][2] = -sin;
            result.matrix[2][1] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[1] > 0.0 or vaxis.vec[1] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][2] = -sin;
            result.matrix[2][0] = sin;
            result.matrix[2][2] = cos;
        }

        if (vaxis.vec[2] > 0.0 or vaxis.vec[2] < 0.0) {
            result.matrix[0][0] = cos;
            result.matrix[0][1] = -sin;
            result.matrix[1][0] = sin;
            result.matrix[1][1] = cos;
        }

        return result.mul4(self);
    }

    fn T() -> Mat4 {
        const new: float[][] = [
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0],
            [0.0, 0.0, 0.0, 0.0]
        ];

        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                new[i][j] = self.matrix[j][i];
            }
        }

        return Mat4 {
            matrix = new
        };
    }

    fn show_m4() {
        for var i = 0; i < 4; i += 1 {
            for var j = 0; j < 4; j += 1 {
                print self.matrix[i][j];
            }
        }
    }
};


print sqrt(4.5);
print cos(-3.0 * PI / 4.0);


const v1 = Vec3 {vec = [1.0, 2.0, 3.0]};
const v2 = Vec3 {vec = [3.0, 2.0, 1.0]};

// v1.show_v3();
// v2.show_v3();

const v4 = v4_from_v3(v1, 1.0);
// v4.show_v4();

const m = Mat3 {
    matrix = [
        [7.0, -4.0, 2.0],
        [3.0, 1.0, -5.0],
        [2.0, 2.0, -5.0]
    ],
};

const m2 = Mat3 {
    matrix = [
        [7.0, -4.0, 2.0],
        [3.0, 1.0, -5.0],
        [2.0, 2.0, -5.0]
    ],
};



// m.adjugate().show_m3();

// print m.determinant();

// m.invert().show_m3();

// m.mul(m2).show_m3();
// m.mulVec(v1).show_v3();

const m3 = Mat4 {
    matrix = [
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0]
    ]
};

const m4 = Mat4 {
    matrix = [
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0],
        [1.0, 2.0, 3.0, 4.0]
    ]
};

// m3.mul4(m4).show_m4();